// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	teamvault "github.com/bborbe/teamvault-utils"
)

type Connector struct {
	FileStub        func(context.Context, teamvault.Key) (teamvault.File, error)
	fileMutex       sync.RWMutex
	fileArgsForCall []struct {
		arg1 context.Context
		arg2 teamvault.Key
	}
	fileReturns struct {
		result1 teamvault.File
		result2 error
	}
	fileReturnsOnCall map[int]struct {
		result1 teamvault.File
		result2 error
	}
	PasswordStub        func(context.Context, teamvault.Key) (teamvault.Password, error)
	passwordMutex       sync.RWMutex
	passwordArgsForCall []struct {
		arg1 context.Context
		arg2 teamvault.Key
	}
	passwordReturns struct {
		result1 teamvault.Password
		result2 error
	}
	passwordReturnsOnCall map[int]struct {
		result1 teamvault.Password
		result2 error
	}
	SearchStub        func(context.Context, string) ([]teamvault.Key, error)
	searchMutex       sync.RWMutex
	searchArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	searchReturns struct {
		result1 []teamvault.Key
		result2 error
	}
	searchReturnsOnCall map[int]struct {
		result1 []teamvault.Key
		result2 error
	}
	UrlStub        func(context.Context, teamvault.Key) (teamvault.Url, error)
	urlMutex       sync.RWMutex
	urlArgsForCall []struct {
		arg1 context.Context
		arg2 teamvault.Key
	}
	urlReturns struct {
		result1 teamvault.Url
		result2 error
	}
	urlReturnsOnCall map[int]struct {
		result1 teamvault.Url
		result2 error
	}
	UserStub        func(context.Context, teamvault.Key) (teamvault.User, error)
	userMutex       sync.RWMutex
	userArgsForCall []struct {
		arg1 context.Context
		arg2 teamvault.Key
	}
	userReturns struct {
		result1 teamvault.User
		result2 error
	}
	userReturnsOnCall map[int]struct {
		result1 teamvault.User
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Connector) File(arg1 context.Context, arg2 teamvault.Key) (teamvault.File, error) {
	fake.fileMutex.Lock()
	ret, specificReturn := fake.fileReturnsOnCall[len(fake.fileArgsForCall)]
	fake.fileArgsForCall = append(fake.fileArgsForCall, struct {
		arg1 context.Context
		arg2 teamvault.Key
	}{arg1, arg2})
	stub := fake.FileStub
	fakeReturns := fake.fileReturns
	fake.recordInvocation("File", []interface{}{arg1, arg2})
	fake.fileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Connector) FileCallCount() int {
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	return len(fake.fileArgsForCall)
}

func (fake *Connector) FileCalls(stub func(context.Context, teamvault.Key) (teamvault.File, error)) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = stub
}

func (fake *Connector) FileArgsForCall(i int) (context.Context, teamvault.Key) {
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	argsForCall := fake.fileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Connector) FileReturns(result1 teamvault.File, result2 error) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = nil
	fake.fileReturns = struct {
		result1 teamvault.File
		result2 error
	}{result1, result2}
}

func (fake *Connector) FileReturnsOnCall(i int, result1 teamvault.File, result2 error) {
	fake.fileMutex.Lock()
	defer fake.fileMutex.Unlock()
	fake.FileStub = nil
	if fake.fileReturnsOnCall == nil {
		fake.fileReturnsOnCall = make(map[int]struct {
			result1 teamvault.File
			result2 error
		})
	}
	fake.fileReturnsOnCall[i] = struct {
		result1 teamvault.File
		result2 error
	}{result1, result2}
}

func (fake *Connector) Password(arg1 context.Context, arg2 teamvault.Key) (teamvault.Password, error) {
	fake.passwordMutex.Lock()
	ret, specificReturn := fake.passwordReturnsOnCall[len(fake.passwordArgsForCall)]
	fake.passwordArgsForCall = append(fake.passwordArgsForCall, struct {
		arg1 context.Context
		arg2 teamvault.Key
	}{arg1, arg2})
	stub := fake.PasswordStub
	fakeReturns := fake.passwordReturns
	fake.recordInvocation("Password", []interface{}{arg1, arg2})
	fake.passwordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Connector) PasswordCallCount() int {
	fake.passwordMutex.RLock()
	defer fake.passwordMutex.RUnlock()
	return len(fake.passwordArgsForCall)
}

func (fake *Connector) PasswordCalls(stub func(context.Context, teamvault.Key) (teamvault.Password, error)) {
	fake.passwordMutex.Lock()
	defer fake.passwordMutex.Unlock()
	fake.PasswordStub = stub
}

func (fake *Connector) PasswordArgsForCall(i int) (context.Context, teamvault.Key) {
	fake.passwordMutex.RLock()
	defer fake.passwordMutex.RUnlock()
	argsForCall := fake.passwordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Connector) PasswordReturns(result1 teamvault.Password, result2 error) {
	fake.passwordMutex.Lock()
	defer fake.passwordMutex.Unlock()
	fake.PasswordStub = nil
	fake.passwordReturns = struct {
		result1 teamvault.Password
		result2 error
	}{result1, result2}
}

func (fake *Connector) PasswordReturnsOnCall(i int, result1 teamvault.Password, result2 error) {
	fake.passwordMutex.Lock()
	defer fake.passwordMutex.Unlock()
	fake.PasswordStub = nil
	if fake.passwordReturnsOnCall == nil {
		fake.passwordReturnsOnCall = make(map[int]struct {
			result1 teamvault.Password
			result2 error
		})
	}
	fake.passwordReturnsOnCall[i] = struct {
		result1 teamvault.Password
		result2 error
	}{result1, result2}
}

func (fake *Connector) Search(arg1 context.Context, arg2 string) ([]teamvault.Key, error) {
	fake.searchMutex.Lock()
	ret, specificReturn := fake.searchReturnsOnCall[len(fake.searchArgsForCall)]
	fake.searchArgsForCall = append(fake.searchArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SearchStub
	fakeReturns := fake.searchReturns
	fake.recordInvocation("Search", []interface{}{arg1, arg2})
	fake.searchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Connector) SearchCallCount() int {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	return len(fake.searchArgsForCall)
}

func (fake *Connector) SearchCalls(stub func(context.Context, string) ([]teamvault.Key, error)) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = stub
}

func (fake *Connector) SearchArgsForCall(i int) (context.Context, string) {
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	argsForCall := fake.searchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Connector) SearchReturns(result1 []teamvault.Key, result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	fake.searchReturns = struct {
		result1 []teamvault.Key
		result2 error
	}{result1, result2}
}

func (fake *Connector) SearchReturnsOnCall(i int, result1 []teamvault.Key, result2 error) {
	fake.searchMutex.Lock()
	defer fake.searchMutex.Unlock()
	fake.SearchStub = nil
	if fake.searchReturnsOnCall == nil {
		fake.searchReturnsOnCall = make(map[int]struct {
			result1 []teamvault.Key
			result2 error
		})
	}
	fake.searchReturnsOnCall[i] = struct {
		result1 []teamvault.Key
		result2 error
	}{result1, result2}
}

func (fake *Connector) Url(arg1 context.Context, arg2 teamvault.Key) (teamvault.Url, error) {
	fake.urlMutex.Lock()
	ret, specificReturn := fake.urlReturnsOnCall[len(fake.urlArgsForCall)]
	fake.urlArgsForCall = append(fake.urlArgsForCall, struct {
		arg1 context.Context
		arg2 teamvault.Key
	}{arg1, arg2})
	stub := fake.UrlStub
	fakeReturns := fake.urlReturns
	fake.recordInvocation("Url", []interface{}{arg1, arg2})
	fake.urlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Connector) UrlCallCount() int {
	fake.urlMutex.RLock()
	defer fake.urlMutex.RUnlock()
	return len(fake.urlArgsForCall)
}

func (fake *Connector) UrlCalls(stub func(context.Context, teamvault.Key) (teamvault.Url, error)) {
	fake.urlMutex.Lock()
	defer fake.urlMutex.Unlock()
	fake.UrlStub = stub
}

func (fake *Connector) UrlArgsForCall(i int) (context.Context, teamvault.Key) {
	fake.urlMutex.RLock()
	defer fake.urlMutex.RUnlock()
	argsForCall := fake.urlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Connector) UrlReturns(result1 teamvault.Url, result2 error) {
	fake.urlMutex.Lock()
	defer fake.urlMutex.Unlock()
	fake.UrlStub = nil
	fake.urlReturns = struct {
		result1 teamvault.Url
		result2 error
	}{result1, result2}
}

func (fake *Connector) UrlReturnsOnCall(i int, result1 teamvault.Url, result2 error) {
	fake.urlMutex.Lock()
	defer fake.urlMutex.Unlock()
	fake.UrlStub = nil
	if fake.urlReturnsOnCall == nil {
		fake.urlReturnsOnCall = make(map[int]struct {
			result1 teamvault.Url
			result2 error
		})
	}
	fake.urlReturnsOnCall[i] = struct {
		result1 teamvault.Url
		result2 error
	}{result1, result2}
}

func (fake *Connector) User(arg1 context.Context, arg2 teamvault.Key) (teamvault.User, error) {
	fake.userMutex.Lock()
	ret, specificReturn := fake.userReturnsOnCall[len(fake.userArgsForCall)]
	fake.userArgsForCall = append(fake.userArgsForCall, struct {
		arg1 context.Context
		arg2 teamvault.Key
	}{arg1, arg2})
	stub := fake.UserStub
	fakeReturns := fake.userReturns
	fake.recordInvocation("User", []interface{}{arg1, arg2})
	fake.userMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Connector) UserCallCount() int {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	return len(fake.userArgsForCall)
}

func (fake *Connector) UserCalls(stub func(context.Context, teamvault.Key) (teamvault.User, error)) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = stub
}

func (fake *Connector) UserArgsForCall(i int) (context.Context, teamvault.Key) {
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	argsForCall := fake.userArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Connector) UserReturns(result1 teamvault.User, result2 error) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	fake.userReturns = struct {
		result1 teamvault.User
		result2 error
	}{result1, result2}
}

func (fake *Connector) UserReturnsOnCall(i int, result1 teamvault.User, result2 error) {
	fake.userMutex.Lock()
	defer fake.userMutex.Unlock()
	fake.UserStub = nil
	if fake.userReturnsOnCall == nil {
		fake.userReturnsOnCall = make(map[int]struct {
			result1 teamvault.User
			result2 error
		})
	}
	fake.userReturnsOnCall[i] = struct {
		result1 teamvault.User
		result2 error
	}{result1, result2}
}

func (fake *Connector) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.fileMutex.RLock()
	defer fake.fileMutex.RUnlock()
	fake.passwordMutex.RLock()
	defer fake.passwordMutex.RUnlock()
	fake.searchMutex.RLock()
	defer fake.searchMutex.RUnlock()
	fake.urlMutex.RLock()
	defer fake.urlMutex.RUnlock()
	fake.userMutex.RLock()
	defer fake.userMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Connector) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ teamvault.Connector = new(Connector)
